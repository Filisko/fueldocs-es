<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Documentación del framework FuelPHP traducida al español">
	<meta name="keywords" content="framework FuelPHP, documentación, traducida, español, castellano, FuelPHP en español, es-ES">
	<link rel="stylesheet" href="./../assets/css/combined.css">
	<link rel="shortcut icon" href="./../favicon.ico" />
	<script src="http://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../';
	</script>
	<script src="./../assets/js/combined.js"></script>
	<title>Estándares de código - General - FuelPHP Documentación</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<h1>
					<strong>FuelPHP, a PHP 5.3 Framework</strong>
					Documentación
				</h1>

				<form id="google_search">
					<p>
						<span id="search_clear">&nbsp;</span>
						<input type="submit" name="search_submit" id="search_submit" value="search" />
						<input type="text" value="" id="search_input" name="search_input" />
					</p>
				</form>
			</div>
			<nav>

				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">tabla de contenidos</a>
			<div class="clear"></div>
		</header>

		<div id="cse">
			<div id="cse_point"></div>
			<div id="cse_content"></div>
		</div>

		<div id="main">

			<h2>Estándares de código</h2>

			<p>Estos estándares de formateo de código y documentación deben ser seguidos por cualquiera que contribuya a Fuel. Cualquier contribución que no cumpla con estas directrices no será aceptada.</p>

			<h3 id="file_formatting">Formato del archivo</h3>

			<h5 id="closing_php_tag">Cerrando el tag PHP</h5>

			<p>Los archivos que solo contienen código PHP deberían omitir siempre el tag de cierre de PHP. (?>). Esto previene muchos pantallos blancos.</p>

			<h5 id="indentation">Indentación</h5>

			<p>Toda la indentación debería ser hecha usando tabulaciones reales, NO espacios.<br />
				Pero la alineación después de la indentación con tabulaciones debería de estar siempre hecha con espacios, NO tabulaciones.</p>

			<pre class="php"><code>		// 2 tabulaciones indentadas
		$var       = 'something';  // indentado con tabulaciones, y valor y comentarios alineados
		$variable  = 'else';       // usando espacios</code></pre>

			<h5 id="line_endings">Finales de línea</h5>

			<p>Los finales de línea deben ser LF al estilo Unix.</p>

			<h5 id="file_naming">Nombres de archivos</h5>

			<p>TODOS los nombres de los archivos deben estar en minúsculas. Sin excepciones.</p>

			<h5 id="encoding">Codificación</h5>

			<p>Los archivos deben ser guardados con codificación UTF-8 y BOM no debe ser utilizado.</p>

			<h3 id="naming_conventions">Convenciones de nomenclatura</h3>

			<h5 id="namespaces">Espacios de nombre</h5>

			<p>Todas las clases del núcleol deben estar bajo el espacio de nombres  Fuel\Core.</p>

			<pre class="php"><code>namespace Fuel\Core;</code></pre>

			<h5 id="classes">Clases</h5>

			<p>Las clases deberían usar guiones bajos para separar las palabras, y cada palabra de la clase debería comenzar con una letra capital. Y el guión bajo se convierte en un separador de directorio durante la carga automática (autoloader). El uso de CamelCase está desaconsejado, pero no se puede prevenir en algunos casos, por ejemplo cuando poner una clase en un subdirectorio no tiene sentido.</p>

			<pre class="php"><code>namespace Fuel\Core;

class Session
{

}</code></pre>

			<pre class="php"><code>namespace Fuel\Core;

class Session_Cookie extends Session_Driver
{

}</code></pre>

			<p>Esto daría lugar a la siguiente ruta de archivo:</p>

			<pre class="php"><code>core/classes/session.php
core/classes/session/cookie.php</code></pre>

			<h5 id="methods_standards">Métodos</h5>

                        <p>Al igual que los nombres de clases, los nombres de los métodos deben usar guiones para separar las palabras, no CamelCase. Los nombres de los métodos también debería de estar todos en minúscula. La visibilidad debería de estar siempre incluída (public, protected, private). <br />
                            Y los guiones bajos pueden ser usados al principio del nombre del método para que quede claro que el método está protegido o es privado para que el método sea considerado como tal cuando es necesario hacerlo público.</p>

			<pre class="php"><code>class Session
{

	public static function get_flash($name, $data)
	{
		// Algún código aquí
	}

}</code></pre>

			<pre class="php"><code>class View
{

	// Array de datos de visión global
	protected static $_global_data = array();

	protected static function capture($view_filename, array $view_data)
	{
		// Algún código aquí
	}

}</code></pre>

			<h5 id="variables">Variables</h5>

			<p>El nombre de las variables deberían ser concisos y contener solo letras en minúscula y guiones para separar las palabras. Variable names should be concise and contain only lower case letters and underscores. Los iteradores bucle deberían ser cortos, preferiblemente de un solo carácter.</p>

			<pre class="php"><code>$primer_nombre
$buffer
for ($i = 0; $i &lt; $max; $i++)</code></pre>

			<h5 id="constants">Constantes</h5>

			<p>Las constantes siguen las mismas directrices que las variables pero con la excepción de que todas las constantes debería de estar en mayúscula</p>

			<pre class="php"><code>MI_CONSTANTE
RUTA_PLANTILLA
TEXTO_PREDETERMINADO</code></pre>

			<h3 id="keywords">Palabras clave</h3>

			<p>Las palabras clave como <kbd>true</kbd>, <kbd>false</kbd>, <kbd>null</kbd>, <kbd>as</kbd>, etc debería de estar todas en minúscula, ya que las mayúsculas están reservadas para las constantes. Lo mismo ocurre con los tipos primitivos como <kbd>array</kbd>, <kbd>integer</kbd>, <kbd>string</kbd>.</p>

			<pre class="php"><code>$var = true;
$var = false;
$var = null;
foreach ($array as $key => $value)
public function mi_funcion(array $array)
function mi_funcion($arg = null)</code></pre>

			<h3 id="control_structures">Control de estructuras</h3>

			<p>Las palabras clave de la estructura tales como <kbd>if</kbd>, <kbd>for</kbd>, <kbd>foreach</kbd>, <kbd>while</kbd>, <kbd>switch</kbd> deberían de ser continuados con un espacio también como lo deberían de estar las variables/parámetros. Las llaves deberían de ser colocadas en una línea nueva, y el <kbd>break</kbd> debería de tener la misma indentación que su <kbd>case</kbd>.</p>

			<pre class="php"><code>if ($arg === true)
{
	//hacer algo aquí
}
elseif ($arg === null)
{
	//hacer algo más aquí
}
else
{
	//todos los casos, hacer algo aquí
}

foreach ($array as $key => $value)
{
	//bucle aquí
}

for ($i = 0; $i &lt; $max; $i++)
{
	//bucle aquí
}

while ($i &lt; $max)
{
	//bucle aquí
}

do
{
	//bucle aquí
}
while ($i &lt; $max)

switch ($var)
{
	case 'valor1':
		//hacer algo aquí
	break;
	default :
		//hacer algo aquí
	break;
}</code></pre>

			<h5 id="alternative_if">Declaraciones <kbd>if</kbd> alternativas</h5>

			<p>En algunos casos, una declaración <kbd>if</kbd> completa es demasiado código para una simple condicional sencilla o para realizar una llamada a una función. En estos casos, puedes usar la lógica de ejecución de PHP para usar una sintáxis de operador booleano más corto.
				Usar <kbd>and</kbd> significa que la segunda parte solo se evaluará si la primera parte fue cierta, usar <kbd>or</kbd> significa que la segunda parte se ejecutará solo si la primera parte fue falsa.<br /> No hagas esto cuando el <kbd>if</kbd> y el <kbd>else</kbd> son necesarios, solo en casos cuando una condicional es necesaria.</p>

			<pre class="php"><code>// en vez de: if (isset($var)) { Config::set('var', $var); }
isset($var) and Config::set('var', $var);

// en vez de: if ( ! isset($var)) { $var = Config::get('var'); }
isset($var) or $var = Config::get('var');

// NO HAGAS ESTO
Uri::segment(3) and $var = Uri::segment(3);
Uri::segment(3) or $var = 'default';

// Esto es mejor:
if (Uri::segment(3))
{
	$var = Uri::segment(3);
}
else
{
	$var = 'default';
}

// O esto:
$var = Uri::segment(3) ? Uri::segment(3) : 'default';

// O de hecho esto:
$var = Uri::segment(3) ?: 'default';</code></pre>

			<h3 id="comparison_logical">Comparaciones, operadores lógicos</h3>

			<p>Comparando lo que devuelve un método/función debería de ser consciente del tipo, por ejemplo algunas funciones podrían devolver <kbd>false</kbd>, y cuando comparamos el tipo de devolución con operadores como <kbd>===</kbd> o <kbd>!==</kbd>. Adicionalmente, el uso de <kbd>and</kbd> o <kbd>or</kbd> es preferido por en vez de <kbd>&amp;&amp;</kbd> o <kbd>||</kbd> para facilitar la lectura. En algunos casos, esto no puede ser evitado y el uso de <kbd>&amp;&amp;</kbd> o <kbd>||</kbd> como es requerido se puede usar. El <kbd>!</kbd> debería tener espacios en ambos lados cuando sea usado.</p>

			<pre class="php"><code>if ($var == false and $otra_variable != 'un_valor')
if ($var === false or mi_funcion() !== false)
if ( ! $var)</code></pre>

			<h5 id="class_interface">Declaraciones de clases/interfaces</h5>

			<p>Las declaraciones de clases/interfaces tienen el bracket de apertura en la siguiente línea:</p>

			<pre class="php"><code>class Session
{

}</code></pre>
			<p>En caso de que la clase esté vacía, las llaves estarán en la misma línea como la definición:</p>

			<pre class="php"><code>class Clase_Vacia { }</code></pre>

			<h5 id="function_method">Declaraciones de Funciones/Métodos/Clausuras</h5>

			<p>La llave de apertura de función/método/cierre siempre debe comenzar en una nueva línea y tienen la misma indentación como su
estructura.</p>

			<pre class="php"><code>class Session
{

	public static function get_flash($nombre, $datoa)
	{
		$closure = function($a, $b)
		{
			// Su código de clausura aquí
		}
	}

}</code></pre>

			<h5 id="variables">Variables</h5>

			<p>Cuando se inicializan las variables, debería de declararse línea por línea. Para mejorar la legibilidad de código, estas deben de estar separadas por línea. Asigna valores y comentarios cuando sea apropiado.</p>

			<pre class="php"><code>$var        = ''; // cada uno en su línea
$other_var  = ''; // cada uno en su línea</code></pre>

			<h5 id="brackets_parenthesis">Llaves y paréntesis</h5>

			<p>Ningún espacio debería de venir después o antes de la llave/paréntesis inicial. No debería de haber ningún espacio antes del cierre de la llave/paréntesis.</p>

			<pre class="php"><code>$array = array(1, 2, 3, 4);
$array['mi_indice'] = 'algo';
for ($i = 0; $i < $max; $i++)</code></pre>

			<h5 id="quotation">Comillas de cadenas</h5>

			<p>Comillas simples son preferibles a las comillas dobles.</p>

			<h5 id="concatenation">Concatenación</h5>

			<p>La concatenación de cadenas no deberían contener espacios alrededor de las partes unidas.</p>

			<pre class="php"><code>//sí
$string = 'mi cadena '.$var.' la otra parte de mi cadena';

//no
$string = 'mi cadena ' . $var . ' la otra parte de mi cadena';</code></pre>

			<h5 id="operators">Operadores</h5>

			<pre class="php"><code>$var = 'algo';
if ($var == 'algo') //espacio antes y después del operador lógico
$var = $some_var + $other_var; //espacio antes y después del operador matemático
$var++; //sin espacio antes del operador de incremento
++$var; //sin espacio después del operador de incremento</code></pre>

			<h5 id="dot-notation">Notación-punto Array</h5>

			<p>
                                Aunque estrictamente hablando no es un estándar de codificación, se utiliza utiliza mucho dentro de las clases del framework al igual que en esta documentación, ya que es no es una notación de PHP común, podría confundir a las personas que son nuevas al framework.
			</p>
			<pre class="php"><code>// cuando ves "always_load.packages = array()", es la manera corta de:
array("always_load" => array("packages" => array(...) ) );
</code></pre>

			<p>Esta notación es usada por la clase Arr, pero también la clase Lang, Config y Session, para acceder individualmente a elementos de un array multi-dimensional.</p>
			<pre class="php"><code>// cuando tienes una estructura de array así
$array = array(
    "always_load" => array(
        "packages" => array(
            "orm",
            "package" => "/my/special/package.php",
        )
     )
);

// ... lo siguiente devolverá "/my/special/package.php":
$path = Arr::get($array, 'always_load.packages.package');
</code></pre>

		</div>

		<footer>
			<p>
				&copy; FuelPHP Development Team 2010-2016 - <a href="http://fuelphp.com">FuelPHP</a> se distribuye bajo la licencia MIT. Traducción al español no oficial - <a href="https://github.com/Filisko/fueldocs-es" target="_blank">Ir al repositorio de GitHub</a>
			</p>
		</footer>
	</div>
</body>
</html>
